{"file_contents":{"README.md":{"content":"# Discord Anonymous Bot\n\nA comprehensive Discord bot with anonymous messaging capabilities, advanced security features, and community tools.\n\n## Features\n\n### Core Functionality\n- **Anonymous Messaging**: Send messages anonymously with terminal-style formatting\n- **Multiple Input Methods**: Use `/anon` slash command, `@anon` prefix, or DM the bot\n- **Terminal Styling**: Messages appear in green terminal-style code blocks\n\n### Security & Moderation\n- **Profanity Filter**: Multi-language content filtering\n- **Rate Limiting**: Prevents spam and abuse\n- **Security Monitoring**: Detects suspicious patterns and threats\n- **Comprehensive Logging**: All actions logged to moderation channel\n- **Role-based Permissions**: Control who can send anonymous messages\n\n### Community Features\n- **Polls**: Create and vote in community polls\n- **Announcements**: Admin-only announcement system\n- **Payment Integration**: PayPal and UPI payment links\n- **Status Commands**: Check bot health and uptime\n\n### Database Integration\n- **PostgreSQL**: Persistent data storage with Drizzle ORM\n- **User Management**: Track Discord users and permissions\n- **Message Logging**: Store anonymous messages with metadata\n- **Security Logs**: Audit trail for all security events\n\n## Setup Instructions\n\n### 1. Discord Bot Setup\n1. Go to [Discord Developer Portal](https://discord.com/developers/applications)\n2. Create a new application\n3. Go to \"Bot\" section and create a bot\n4. Copy the bot token\n5. Set the token in Replit Secrets as `DISCORD_BOT_TOKEN`\n\n### 2. Bot Permissions\nAdd the bot to your server with these permissions:\n- Send Messages\n- Read Message History\n- Use Slash Commands\n- Manage Messages (for deleting original messages)\n- View Channels\n\n### 3. Channel Configuration\nUpdate these channel IDs in your environment variables:\n- `ANONYMOUS_CHANNEL`: Where anonymous messages appear\n- `MOD_CHANNEL`: Where logs are sent\n- `ALLOWED_ROLE_ID`: Role that can send anonymous messages\n- `ADMIN_ROLE_ID`: Role that can use admin commands\n\n## Available Commands\n\n### Slash Commands\n- `/anon <message>` - Send an anonymous message\n- `/poll <question> <options>` - Create a poll (comma-separated options)\n- `/vote <poll_id> <option>` - Vote in a poll\n- `/pollresults <poll_id>` - View poll results\n- `/announce <message>` - Send announcement (admin only)\n- `/paypal` - Get PayPal payment link\n- `/qr` - Get UPI payment information\n- `/status` - Check bot status\n- `/clear` - Clear anonymous channel (admin only)\n\n### Text Commands\n- `@anon <message>` - Send anonymous message from any channel\n- `!status` - Check bot status\n- `!help` - Show help information\n\n### DM Support\nSend a direct message to the bot to post anonymously.\n\n## Security Features\n\n### Content Filtering\n- Comprehensive profanity filter\n- Support for multiple languages\n- Blocks offensive and inappropriate content\n\n### Rate Limiting\n- Maximum 5 messages per minute per user\n- Automatic rate limit enforcement\n- Security alerts for violations\n\n### Threat Detection\n- Discord invite link detection\n- External link filtering (except PayPal)\n- Mass mention prevention\n- Suspicious keyword detection\n- Character spam prevention\n\n## Environment Variables\n\nRequired:\n- `DISCORD_BOT_TOKEN` - Your Discord bot token\n\nOptional (with defaults):\n- `ANONYMOUS_CHANNEL` - Anonymous message channel ID\n- `MOD_CHANNEL` - Moderation log channel ID\n- `ALLOWED_ROLE_ID` - Role that can send anonymous messages\n- `ADMIN_ROLE_ID` - Role with admin permissions\n- `ROLE_NAME` - Protected role name (default: \"Admin\")\n\n## Database Schema\n\nThe bot uses PostgreSQL with these tables:\n- `users` - Discord user data and permissions\n- `anonymous_messages` - Message tracking and metadata\n- `security_logs` - Security events and violations\n- `polls` - Community polls and voting\n- `poll_votes` - Individual vote tracking\n- `rate_limits` - User rate limiting data\n- `applications` - User applications (future feature)\n- `auctions` - Marketplace auctions (future feature)\n\n## Running the Bot\n\nThe bot runs automatically in Replit. Just provide your `DISCORD_BOT_TOKEN` in the Secrets tab and the bot will connect to Discord.\n\n## Support\n\nIf you need help setting up the bot:\n1. Check that your Discord bot token is valid\n2. Ensure the bot has proper permissions in your server\n3. Verify channel IDs are correct\n4. Check the console logs for any error messages\n\nThe bot includes comprehensive logging to help with troubleshooting.","size_bytes":4450},"avatar.js":{"content":"// Simple avatar generation module\n// This creates a simple text-based avatar or returns a default one\n\n/**\n * Generate a simple avatar for anonymous users\n * @param {string} seed - Seed for avatar generation\n * @returns {string} - Simple avatar representation\n */\nexport default function getAvatar(seed = 'default') {\n    // Simple text-based avatars using Unicode characters\n    const avatars = [\n        '🤖', '👤', '🎭', '👻', '🎪', '🎨', '🎯', '🎲',\n        '⚡', '🔥', '💎', '🌟', '🔮', '🎊', '🎈', '🎁',\n        '🚀', '🛸', '⭐', '🌙', '☄️', '🌈', '💫', '✨'\n    ];\n    \n    // Use seed to determine avatar\n    let hash = 0;\n    for (let i = 0; i < seed.length; i++) {\n        const char = seed.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    const index = Math.abs(hash) % avatars.length;\n    return avatars[index];\n}\n\n/**\n * Generate a colored terminal avatar\n * @param {string} seed - Seed for avatar generation\n * @returns {string} - Terminal colored avatar\n */\nexport function getTerminalAvatar(seed = 'default') {\n    const colors = [\n        '\\u001b[31m', // Red\n        '\\u001b[32m', // Green\n        '\\u001b[33m', // Yellow\n        '\\u001b[34m', // Blue\n        '\\u001b[35m', // Magenta\n        '\\u001b[36m', // Cyan\n        '\\u001b[37m', // White\n    ];\n    \n    const shapes = ['●', '■', '▲', '♦', '★', '♠', '♥', '♣'];\n    \n    let hash = 0;\n    for (let i = 0; i < seed.length; i++) {\n        const char = seed.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash;\n    }\n    \n    const colorIndex = Math.abs(hash) % colors.length;\n    const shapeIndex = Math.abs(hash >> 3) % shapes.length;\n    \n    return `${colors[colorIndex]}${shapes[shapeIndex]}\\u001b[0m`;\n}\n","size_bytes":1862},"drizzle.config.js":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  schema: \"./shared/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL\n  }\n});\n","size_bytes":213},"index.js":{"content":"import express from \"express\";\nimport { config } from \"dotenv\";\nimport { Client, GatewayIntentBits, Events, Partials, SlashCommandBuilder, REST, Routes, ActionRowBuilder, ButtonBuilder, ButtonStyle } from \"discord.js\";\nimport sharp from 'sharp';\nimport fetch from 'node-fetch';\n\n// Load environment variables\nconfig();\n\nconst app = express();\n\n// Environment variables\nconst anonymousChannel = process.env.ANONYMOUS_CHANNEL || \"1406547609996361869\";\nconst roleName = process.env.ROLE_NAME || \"Admin\";\nconst allowedRoleId = process.env.ALLOWED_ROLE_ID || \"1384805029369876561\"; // Role that can send anonymous messages\nconst adminRoleId = process.env.ADMIN_ROLE_ID || \"1210529711843708929\"; // Role that can send announcements\nconst superAdminIds = [\"959692217885294632\"]; // Super admin user IDs with full access\nconst modChannel = process.env.MOD_CHANNEL || \"1406548297002258462\"; // Default log channel\nconst applicationChannel = \"1406725485831913545\"; // Applications review channel\nconst auctionChannel = process.env.AUCTION_CHANNEL || anonymousChannel; // Auction listings channel\nconst token = \"MTQwNjUyOTkyNDM4MjA2NDc2MQ.GLS5WF.fVBZiRyXkU9QgUqyCzZnWNR2OI7I9CwvhitjoI\";\n\n// Blocked words list - profanity filter\nconst blockedWords = [\n    \"fuck\", \"fuk\", \"fck\", \"fukkk\", \"f.u.c.k\", \"fucc\", \"fuxk\",\n    \"shit\", \"sh1t\", \"sh!t\", \"shet\", \"shyt\",\n    \"bitch\", \"b!tch\", \"bi7ch\", \"btch\", \"bich\",\n    \"asshole\", \"a$$hole\", \"azzhole\", \"ashole\",\n    \"dick\", \"d1ck\", \"dik\", \"diq\", \"deek\",\n    \"cock\", \"c0ck\", \"cok\", \"coq\",\n    \"pussy\", \"pussi\", \"pusy\", \"p00sy\",\n    \"bastard\", \"bastrd\", \"ba$tard\", \"bstrd\",\n    \"slut\", \"slutt\", \"sl@t\", \"slutty\",\n    \"whore\", \"whoar\", \"w.h.o.r.e\", \"h0e\", \"hoe\",\n    \"faggot\", \"f@g\", \"fa66ot\", \"phag\", \"fag\",\n    \"cunt\", \"c*nt\", \"cnt\", \"kunt\",\n    \"nigger\", \"n1gger\", \"nigg3r\", \"nigga\", \"niga\",\n    \"motherfucker\", \"m0therfuker\", \"muthafucka\", \"mf\", \"m.f.\",\n    \"madarchod\", \"m@darchod\", \"m4darchod\", \"m.c.\", \"mc\",\n    \"behenchod\", \"bhenchod\", \"bhnchod\", \"b.c.\", \"bc\",\n    \"chutiya\", \"chutya\", \"chutia\", \"ch@tiya\", \"chut\",\n    \"gandu\", \"gaandu\", \"g@ndu\", \"g4ndu\",\n    \"randi\", \"r@ndi\", \"raandi\",\n    \"launda\", \"lund\", \"l0nd\", \"lundd\",\n    \"lavda\", \"lawda\", \"laveda\",\n    \"suar\", \"sooar\", \"suwar\", \"swr\",\n    \"kutta\", \"kutti\", \"kuttiya\", \"kutte\", \"kutt@\",\n    \"harami\", \"haramzade\", \"haramzada\",\n    \"bhosdike\", \"bhosri\", \"bhosda\", \"bhosriwala\",\n    \"chodu\", \"chod\", \"chodna\", \"chodenge\",\n    \"tatti\", \"t@tti\", \"tatty\",\n    \"gaand\", \"gand\", \"g@nd\", \"g4and\"\n];\n\n// Function to check for blocked words\nfunction containsBlockedWords(text) {\n    const lowerText = text.toLowerCase();\n    return blockedWords.some(word => {\n        const lowerWord = word.toLowerCase();\n        // Check for exact word matches and words with boundaries\n        const regex = new RegExp(`\\\\b${lowerWord.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'i');\n        return regex.test(lowerText) || lowerText.includes(lowerWord);\n    });\n}\n\n// Create terminal-style anonymous message\nfunction createTerminalAnonymousMessage(content) {\n    const userId = generateAnonUserId();\n    return `\\`\\`\\`ansi\\n\\u001b[32m${userId}: ${content}\\n\\`\\`\\``;\n}\n\n// Generate automatic anonymous user ID\nfunction generateAnonUserId() {\n    const prefixes = ['shadow', 'ghost', 'phantom', 'cipher', 'void', 'nexus', 'omega', 'alpha', 'delta', 'echo'];\n    const numbers = Math.floor(Math.random() * 999) + 1;\n    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];\n    return `${prefix}_${numbers.toString().padStart(3, '0')}`;\n}\n\n// In-memory storage for polls (in production, use a database)\nconst activePolls = new Map();\nconst userVotes = new Map(); // Track user votes to prevent duplicate voting\nconst activeAuctions = new Map();\nconst approvedUsers = new Set();\nconst pendingApplications = new Map();\nconst userApplications = new Map();\n\n// Security monitoring\nconst securityLogs = new Map();\nconst rateLimits = new Map(); // Rate limiting for security\n\n// Enhanced security check\nfunction checkSecurityThreat(message, userId) {\n    const suspiciousPatterns = [\n        /discord\\.gg\\/[a-zA-Z0-9]+/i, // Discord invite links\n        /http[s]?:\\/\\/(?!paypal\\.me)/i, // External links (except PayPal)\n        /@everyone|@here/i, // Mass mentions\n        /\\b(hack|exploit|ddos|bot|spam)\\b/i, // Suspicious keywords\n        /(.)\\1{10,}/i // Character spam\n    ];\n    \n    const now = Date.now();\n    const userRate = rateLimits.get(userId) || { count: 0, timestamp: now };\n    \n    // Rate limiting check (max 5 messages per minute)\n    if (now - userRate.timestamp < 60000) {\n        userRate.count++;\n        if (userRate.count > 5) {\n            return { threat: true, reason: 'Rate limit exceeded' };\n        }\n    } else {\n        userRate.count = 1;\n        userRate.timestamp = now;\n    }\n    rateLimits.set(userId, userRate);\n    \n    // Pattern matching\n    for (const pattern of suspiciousPatterns) {\n        if (pattern.test(message)) {\n            return { threat: true, reason: 'Suspicious content detected' };\n        }\n    }\n    \n    return { threat: false };\n}\n\n// Image resizing function\nasync function resizeImageTo150x150(imageUrl) {\n    try {\n        const response = await fetch(imageUrl);\n        if (!response.ok) return null;\n        \n        const buffer = await response.buffer();\n        const resizedBuffer = await sharp(buffer)\n            .resize(150, 150, {\n                fit: 'cover',\n                position: 'center'\n            })\n            .jpeg({ quality: 80 })\n            .toBuffer();\n        \n        return resizedBuffer;\n    } catch (error) {\n        console.error('❌ Error resizing image:', error);\n        return null;\n    }\n}\n\n// Generate hacker-style anonymous user ID for auctions\nfunction generateHackerUserId() {\n    const prefixes = ['anon', 'ghost', 'shadow', 'cipher', 'void', 'null', 'phantom', 'nexus'];\n    const numbers = Math.floor(Math.random() * 9999) + 1000;\n    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];\n    return `${prefix}_${numbers}`;\n}\n\n// Validate required environment variables\nif (!token) {\n    console.log(\"❌ Please set DISCORD_BOT_TOKEN environment variable\");\n    console.log(\"📝 The bot will still start but won't be able to connect to Discord\");\n    console.log(\"🔗 Get your token from: https://discord.com/developers/applications\");\n}\n\n// Create Discord client with basic intents only\nconst client = new Client({\n    intents: [\n        GatewayIntentBits.Guilds, \n        GatewayIntentBits.GuildMessages\n    ]\n});\n\n// Function to clear channel and send startup sequence\nasync function clearChannelAndStartup() {\n    try {\n        const anonChannel = await client.channels.fetch(anonymousChannel);\n        \n        // Clear all messages in the channel (bot restart = clean slate)\n        let fetched;\n        do {\n            fetched = await anonChannel.messages.fetch({ limit: 100 });\n            if (fetched.size > 0) {\n                // Filter messages that can be bulk deleted (less than 14 days old)\n                const bulkDeletable = fetched.filter(msg => msg.createdTimestamp > Date.now() - 1209600000);\n                const oldMessages = fetched.filter(msg => msg.createdTimestamp <= Date.now() - 1209600000);\n                \n                // Bulk delete recent messages\n                if (bulkDeletable.size > 0) {\n                    await anonChannel.bulkDelete(bulkDeletable);\n                }\n                \n                // Delete old messages individually\n                for (const [id, message] of oldMessages) {\n                    try {\n                        await message.delete();\n                        await new Promise(resolve => setTimeout(resolve, 100)); // Rate limit protection\n                    } catch (err) {\n                        console.log(`Could not delete message ${id}: ${err.message}`);\n                    }\n                }\n            }\n        } while (fetched.size >= 100);\n        \n        console.log('✅ Anonymous channel cleared successfully');\n        \n        // Send startup sequence with green color\n        const startupMessages = [\n            \"```ansi\",\n            \"\\u001b[32m[BOOT] >> Initializing secure connection...\",\n            \"\\u001b[32m[BOOT] >> Handshake complete with NODE_001\",\n            \"\\u001b[32m[SYS]  >> Loading core modules ██████████ 100%\",\n            \"\\u001b[32m[NET]  >> Encrypted tunnel established [TLS v3.9]\",\n            \"\\u001b[32m[ID]   >> Identity mask engaged :: Layer-256 active\",\n            \"\\u001b[32m[SEC]  >> Firewall bypass injected... [SUCCESS]\",\n            \"\\u001b[32m\",\n            \"\\u001b[32m┌─────────────────────────────────────┐\",\n            \"\\u001b[32m│   🔐  S E C U R E   L O G I N  v3.1 │\",\n            \"\\u001b[32m└─────────────────────────────────────┘\",\n            \"\\u001b[32m\",\n            \"\\u001b[32m[USER] :: ANONYMOUS\",\n            \"\\u001b[32m[PASS] :: ********\",\n            \"\\u001b[32m\",\n            \"\\u001b[32m[AUTH] >> Authentication [VERIFIED]\",\n            \"\\u001b[32m[AUTH] >> Access Level = ROOT\",\n            \"\\u001b[32m\",\n            \"\\u001b[32m┌─────────────────────────────────────┐\",\n            \"\\u001b[32m│   W E L C O M E   B A C K ,         │\",\n            \"\\u001b[32m│   A N O N Y M O U S   O P E R A T I V E │\",\n            \"\\u001b[32m└─────────────────────────────────────┘\",\n            \"\\u001b[32m\",\n            \"\\u001b[32m[CHK] >> Running system diagnostics...\",\n            \"\\u001b[32m        ▸ Proxy Chain [OK]\",\n            \"\\u001b[32m        ▸ VPN Multi-Layer [OK]\",\n            \"\\u001b[32m        ▸ Spoof Engine [ACTIVE]\",\n            \"\\u001b[32m        ▸ Traceback : NULL\",\n            \"\\u001b[32m\",\n            \"\\u001b[32m[SYS]  >> Initialization ██████████ 100%\",\n            \"\\u001b[32m[ACCESS] >> GRANTED :: SESSION OPENED\",\n            \"```\"\n        ];\n        \n        // Send startup sequence as one message\n        await anonChannel.send(startupMessages.join('\\n'));\n        console.log('✅ Startup sequence sent to anonymous channel');\n        \n    } catch (error) {\n        console.error('❌ Error clearing channel and sending startup sequence:', error.message);\n    }\n}\n\n// Register slash commands\nasync function registerSlashCommands() {\n    const commands = [\n        new SlashCommandBuilder()\n            .setName('anon')\n            .setDescription('Send an anonymous message')\n            .addStringOption(option =>\n                option.setName('message')\n                    .setDescription('The message to send anonymously')\n                    .setRequired(true)\n            ),\n        new SlashCommandBuilder()\n            .setName('poll')\n            .setDescription('Create a poll')\n            .addStringOption(option =>\n                option.setName('question')\n                    .setDescription('The poll question')\n                    .setRequired(true)\n            )\n            .addStringOption(option =>\n                option.setName('options')\n                    .setDescription('Poll options separated by commas')\n                    .setRequired(true)\n            ),\n        new SlashCommandBuilder()\n            .setName('announce')\n            .setDescription('Send an announcement (admin only)')\n            .addStringOption(option =>\n                option.setName('message')\n                    .setDescription('The announcement message')\n                    .setRequired(true)\n            ),\n        new SlashCommandBuilder()\n            .setName('status')\n            .setDescription('Check bot status'),\n        new SlashCommandBuilder()\n            .setName('clear')\n            .setDescription('Clear anonymous channel (admin only)'),\n        new SlashCommandBuilder()\n            .setName('vote')\n            .setDescription('Vote in a poll')\n            .addStringOption(option =>\n                option.setName('poll_id')\n                    .setDescription('The poll ID')\n                    .setRequired(true))\n            .addIntegerOption(option =>\n                option.setName('option')\n                    .setDescription('Option number to vote for')\n                    .setRequired(true)),\n        new SlashCommandBuilder()\n            .setName('pollresults')\n            .setDescription('View poll results')\n            .addStringOption(option =>\n                option.setName('poll_id')\n                    .setDescription('The poll ID')\n                    .setRequired(true)),\n        new SlashCommandBuilder()\n            .setName('paypal')\n            .setDescription('Get PayPal payment link'),\n        new SlashCommandBuilder()\n            .setName('qr')\n            .setDescription('Get UPI payment information'),\n        new SlashCommandBuilder()\n            .setName('sell')\n            .setDescription('List an item for auction')\n            .addStringOption(option =>\n                option.setName('item')\n                    .setDescription('Item name/description')\n                    .setRequired(true))\n            .addIntegerOption(option =>\n                option.setName('price')\n                    .setDescription('Starting price')\n                    .setRequired(true))\n            .addAttachmentOption(option =>\n                option.setName('image')\n                    .setDescription('Item image')\n                    .setRequired(true)),\n        new SlashCommandBuilder()\n            .setName('bid')\n            .setDescription('Place a bid on an auction')\n            .addStringOption(option =>\n                option.setName('auction_id')\n                    .setDescription('Auction ID')\n                    .setRequired(true))\n            .addIntegerOption(option =>\n                option.setName('amount')\n                    .setDescription('Bid amount')\n                    .setRequired(true)),\n        new SlashCommandBuilder()\n            .setName('apply')\n            .setDescription('Submit application to participate in auctions')\n            .addStringOption(option =>\n                option.setName('fullname')\n                    .setDescription('Your full real name')\n                    .setRequired(true))\n            .addStringOption(option =>\n                option.setName('id_number')\n                    .setDescription('SSN or Citizen ID number')\n                    .setRequired(true))\n            .addAttachmentOption(option =>\n                option.setName('profile_picture')\n                    .setDescription('Your profile picture for verification')\n                    .setRequired(true)),\n        new SlashCommandBuilder()\n            .setName('auctions')\n            .setDescription('View active auctions')\n    ];\n\n    try {\n        const rest = new REST({ version: '10' }).setToken(token);\n        \n        console.log('🔄 Started refreshing application (/) commands.');\n        \n        await rest.put(\n            Routes.applicationCommands(client.user.id),\n            { body: commands }\n        );\n        \n        console.log('✅ Successfully reloaded application (/) commands.');\n    } catch (error) {\n        console.error('❌ Error registering slash commands:', error);\n    }\n}\n\n// Bot ready event\nclient.once(Events.ClientReady, async () => {\n    console.log(`✅ Bot is online as ${client.user.tag}`);\n    console.log(`📡 Anonymous channel: ${anonymousChannel}`);\n    if (modChannel) console.log(`🛡️ Mod channel: ${modChannel}`);\n    if (roleName) console.log(`👤 Protected role: ${roleName}`);\n    if (allowedRoleId) console.log(`🔑 Required role ID: ${allowedRoleId}`);\n    if (adminRoleId) console.log(`👑 Admin role ID: ${adminRoleId}`);\n    console.log(`👨‍💻 Super Admin IDs: ${superAdminIds.join(', ')}`);\n    \n    // Auto-approve super admins for marketplace access\n    superAdminIds.forEach(id => {\n        approvedUsers.add(id);\n    });\n    console.log(`✅ Super admins granted marketplace access automatically`);\n    if (allowedRoleId) console.log(`🔑 Required role ID: ${allowedRoleId}`);\n    if (adminRoleId) console.log(`👑 Admin role ID: ${adminRoleId}`);\n    \n    // Clear channel and send startup sequence\n    await clearChannelAndStartup();\n    \n    // Register slash commands\n    await registerSlashCommands();\n});\n\n// Handle interactions (slash commands and buttons)\nclient.on(Events.InteractionCreate, async (interaction) => {\n    // Handle button interactions\n    if (interaction.isButton()) {\n        await handleButtonInteraction(interaction);\n        return;\n    }\n\n    if (!interaction.isChatInputCommand()) return;\n\n    const { commandName } = interaction;\n\n    try {\n        if (commandName === 'anon') {\n            await handleAnonCommand(interaction);\n        } else if (commandName === 'poll') {\n            await handlePollCommand(interaction);\n        } else if (commandName === 'vote') {\n            await handleVoteCommand(interaction);\n        } else if (commandName === 'pollresults') {\n            await handlePollResultsCommand(interaction);\n        } else if (commandName === 'announce') {\n            await handleAnnouncementCommand(interaction);\n        } else if (commandName === 'paypal') {\n            await handlePaypalCommand(interaction);\n        } else if (commandName === 'qr') {\n            await handleQRCommand(interaction);\n        } else if (commandName === 'status') {\n            await handleStatusCommand(interaction);\n        } else if (commandName === 'clear') {\n            await handleClearCommand(interaction);\n        } else if (commandName === 'sell') {\n            await handleSellCommand(interaction);\n        } else if (commandName === 'bid') {\n            await handleBidCommand(interaction);\n        } else if (commandName === 'apply') {\n            await handleApplyCommand(interaction);\n        } else if (commandName === 'auctions') {\n            await handleAuctionsCommand(interaction);\n        }\n    } catch (error) {\n        console.error('❌ Error handling slash command:', error.message);\n        if (!interaction.replied) {\n            await interaction.reply({ content: \"❌ An error occurred while processing your command.\", flags: 64 });\n        }\n    }\n});\n\n// Message handling\nclient.on(Events.MessageCreate, async (message) => {\n    try {\n        // Ignore bot messages\n        if (message.author.bot) return;\n\n        const channel = message.channel;\n        const randomId = Math.floor(Math.random() * 100000);\n        const date = new Date();\n        const messageStamp = \"#\" + randomId + \" \" + date.toLocaleDateString();\n        const messageContent = message.content || \"[Message content unavailable]\";\n\n        // Handle DM messages\n        if (channel.type === 1) {\n            await handleDmMessage(message, messageStamp);\n            return;\n        }\n\n        // Handle commands in any channel\n        if (messageContent.startsWith('!')) {\n            await handleCommand(message, messageStamp);\n            return;\n        }\n\n        // Check for @anon pattern for simple anonymous messages in any channel\n        if (messageContent.toLowerCase().startsWith('@anon ')) {\n            const username = message.author.username || \"Unknown User\";\n            const anonMessage = messageContent.substring(6).trim(); // Remove \"@anon \" prefix\n            \n            if (!anonMessage) {\n                await message.reply(\"❌ Please provide a message after @anon\");\n                return;\n            }\n\n            // Enhanced security and content checks\n            const securityCheck = checkSecurityThreat(anonMessage, message.author.id);\n            if (securityCheck.threat) {\n                await message.reply(`🛡️ Security Alert: ${securityCheck.reason}. Message blocked for safety.`);\n                \n                // Log security incident\n                try {\n                    const logChannel = await client.channels.fetch(modChannel);\n                    await logChannel.send(`**🚨 SECURITY ALERT**\\nUser: ${username} (${message.author.id})\\nThreat: ${securityCheck.reason}\\nTimestamp: ${new Date().toLocaleString()}\\nBlocked Content: ${anonMessage}`);\n                } catch (error) {\n                    console.error('❌ Error logging security incident:', error.message);\n                }\n                return;\n            }\n\n            // Check for blocked words\n            if (containsBlockedWords(anonMessage)) {\n                await message.reply(\"❌ Message blocked due to inappropriate language. Please avoid using offensive words.\");\n                \n                // Log abuse attempt\n                try {\n                    const logChannel = await client.channels.fetch(modChannel);\n                    await logChannel.send(`**🚫 BLOCKED @ANON MESSAGE**\\nUser: ${username} (${message.author.id})\\nTimestamp: ${new Date().toLocaleString()}\\nReason: Inappropriate language detected\\nFrom Channel: #${message.channel.name} (${message.channel.id})\\nBlocked Content: ${anonMessage}`);\n                } catch (error) {\n                    console.error('❌ Error logging blocked @anon message:', error.message);\n                }\n                return;\n            }\n\n            // Check if user has the required role to send anonymous messages\n            if (allowedRoleId && !message.member?.roles.cache.has(allowedRoleId)) {\n                await message.reply(\"❌ You don't have permission to send anonymous messages.\");\n                return;\n            }\n\n            // Check if user has protected role\n            if (roleName && message.member?.roles.cache.some((role) => role.name === roleName)) {\n                await message.reply(\"❌ Users with the admin role cannot send anonymous messages.\");\n                return;\n            }\n\n            // Delete the original message\n            try {\n                await message.delete();\n            } catch (error) {\n                console.log('Could not delete original message');\n            }\n\n            // Send terminal-style anonymous message to anonymous channel\n            try {\n                const anonChannel = await client.channels.fetch(anonymousChannel);\n                const terminalMessage = createTerminalAnonymousMessage(anonMessage);\n                await anonChannel.send(terminalMessage);\n\n                // Log to mod channel\n                try {\n                    const logChannel = await client.channels.fetch(modChannel);\n                    await logChannel.send(`**📝 ANONYMOUS MESSAGE LOG**\\nUser: ${username} (${message.author.id})\\n${messageStamp}\\nFrom Channel: #${message.channel.name} (${message.channel.id})\\nMessage: ${anonMessage}`);\n                } catch (error) {\n                    console.error('❌ Error logging @anon message:', error.message);\n                }\n            } catch (error) {\n                console.error('❌ Error sending anonymous message:', error.message);\n                await message.reply(\"❌ Could not send anonymous message. Please try again.\");\n            }\n\n            return;\n        }\n\n        // Only process messages in the anonymous channel\n        if (channel.id !== anonymousChannel) return;\n        \n        // Check if user has the required role to send anonymous messages\n        if (allowedRoleId && !message.member?.roles.cache.has(allowedRoleId)) {\n            await message.reply(\"❌ You don't have permission to send anonymous messages in this channel.\");\n            return;\n        }\n\n        // Check if user has protected role (admins can't send anonymous messages)\n        if (roleName && message.member?.roles.cache.some((role) => role.name === roleName)) {\n            await message.reply(\"❌ Users with the admin role cannot send anonymous messages.\");\n            return;\n        }\n\n        await handleChannelMessage(channel, message, messageStamp);\n    } catch (error) {\n        console.error('❌ Error in message handler:', error.message);\n    }\n});\n\n// Handle DM messages\nasync function handleDmMessage(message, messageStamp) {\n    try {\n        const username = message.author.username || \"Unknown User\";\n        const messageContent = message.content || \"[Message content unavailable]\";\n        \n        // Security and content checks\n        const securityCheck = checkSecurityThreat(messageContent, message.author.id);\n        if (securityCheck.threat) {\n            await message.reply(`🛡️ Security Alert: ${securityCheck.reason}. Message blocked for safety.`);\n            return;\n        }\n        \n        if (containsBlockedWords(messageContent)) {\n            await message.reply(\"❌ Message blocked due to inappropriate language. Please avoid using offensive words.\");\n            return;\n        }\n        \n        // Send to anonymous channel\n        const anonChannel = await client.channels.fetch(anonymousChannel);\n        const terminalMessage = createTerminalAnonymousMessage(messageContent);\n        await anonChannel.send(terminalMessage);\n        \n        // Confirm to user\n        await message.reply(\"✅ Your anonymous message has been sent!\");\n        \n        // Log to mod channel\n        try {\n            const logChannel = await client.channels.fetch(modChannel);\n            await logChannel.send(`**📝 DM ANONYMOUS MESSAGE**\\nUser: ${username} (${message.author.id})\\nMessage: ${messageContent}\\nTimestamp: ${new Date().toLocaleString()}`);\n        } catch (error) {\n            console.error('❌ Error logging DM message:', error.message);\n        }\n        \n    } catch (error) {\n        console.error('❌ Error handling DM message:', error.message);\n        await message.reply(\"❌ Sorry, there was an error processing your message.\");\n    }\n}\n\n// Handle commands\nasync function handleCommand(message, messageStamp) {\n    const args = message.content.slice(1).split(' ');\n    const command = args[0].toLowerCase();\n    \n    try {\n        switch (command) {\n            case 'status':\n                await message.reply(`✅ Bot is online!\\n🕐 Uptime: ${Math.floor(process.uptime())} seconds\\n📡 Ping: ${client.ws.ping}ms`);\n                break;\n                \n            case 'help':\n                const helpEmbed = {\n                    color: 0x00ff00,\n                    title: '🤖 Bot Commands',\n                    description: 'Available commands:',\n                    fields: [\n                        { name: '!status', value: 'Check bot status', inline: true },\n                        { name: '!help', value: 'Show this help message', inline: true },\n                        { name: '@anon <message>', value: 'Send anonymous message', inline: false },\n                        { name: 'DM bot', value: 'Send anonymous message via DM', inline: false }\n                    ],\n                    timestamp: new Date()\n                };\n                await message.reply({ embeds: [helpEmbed] });\n                break;\n                \n            default:\n                await message.reply(\"❌ Unknown command. Use `!help` for available commands.\");\n        }\n    } catch (error) {\n        console.error('❌ Error handling command:', error.message);\n        await message.reply(\"❌ Sorry, there was an error processing your command.\");\n    }\n}\n\n// Handle channel messages\nasync function handleChannelMessage(channel, message, messageStamp) {\n    try {\n        const username = message.author.username || \"Unknown User\";\n        const messageContent = message.content || \"[Message content unavailable]\";\n        \n        // Check for blocked words\n        if (containsBlockedWords(messageContent)) {\n            await message.reply(\"❌ Message blocked due to inappropriate language. Please avoid using offensive words.\");\n            \n            // Log abuse attempt\n            try {\n                const logChannel = await client.channels.fetch(modChannel);\n                await logChannel.send(`**🚫 BLOCKED CHANNEL MESSAGE**\\nUser: ${username} (${message.author.id})\\nTimestamp: ${new Date().toLocaleString()}\\nChannel: #${channel.name} (${channel.id})\\nReason: Inappropriate language detected\\nBlocked Content: ${messageContent}`);\n            } catch (error) {\n                console.error('❌ Error logging blocked message:', error.message);\n            }\n            return;\n        }\n\n        // Delete the original message\n        try {\n            await message.delete();\n        } catch (error) {\n            console.log('Could not delete original message');\n        }\n\n        // Create terminal-style anonymous message\n        const anonymousMessage = createTerminalAnonymousMessage(messageContent);\n        \n        await channel.send(anonymousMessage);\n\n        // Log to mod channel\n        try {\n            const logChannel = await client.channels.fetch(modChannel);\n            await logChannel.send(`**📝 CHANNEL LOG**\\nUser: ${username} (${message.author.id})\\n${messageStamp}\\nChannel: #${channel.name} (${channel.id})\\nMessage: ${messageContent}`);\n        } catch (error) {\n            console.error('❌ Error logging channel message:', error.message);\n        }\n    } catch (error) {\n        console.error('❌ Error handling channel message:', error.message);\n    }\n}\n\n// Handle /anon slash command\nasync function handleAnonCommand(interaction) {\n    const message = interaction.options.getString('message');\n    const username = interaction.user.username || \"Unknown User\";\n    \n    // Check for blocked words\n    if (containsBlockedWords(message)) {\n        await interaction.reply({ content: \"❌ Message blocked due to inappropriate language. Please avoid using offensive words.\", flags: 64 });\n        return;\n    }\n\n    // Check if user has the required role\n    if (allowedRoleId && !interaction.member?.roles.cache.has(allowedRoleId)) {\n        await interaction.reply({ content: \"❌ You don't have permission to send anonymous messages.\", flags: 64 });\n        return;\n    }\n\n    // Check if user has protected role\n    if (roleName && interaction.member?.roles.cache.some((role) => role.name === roleName)) {\n        await interaction.reply({ content: \"❌ Users with the admin role cannot send anonymous messages.\", flags: 64 });\n        return;\n    }\n\n    try {\n        const anonChannel = await client.channels.fetch(anonymousChannel);\n        const terminalMessage = createTerminalAnonymousMessage(message);\n        await anonChannel.send(terminalMessage);\n        \n        await interaction.reply({ content: \"✅ Your anonymous message has been sent!\", flags: 64 });\n\n        // Log to mod channel\n        try {\n            const logChannel = await client.channels.fetch(modChannel);\n            await logChannel.send(`**📝 /ANON COMMAND LOG**\\nUser: ${username} (${interaction.user.id})\\nTimestamp: ${new Date().toLocaleString()}\\nMessage: ${message}`);\n        } catch (error) {\n            console.error('❌ Error logging /anon command:', error.message);\n        }\n    } catch (error) {\n        console.error('❌ Error sending anonymous message:', error.message);\n        await interaction.reply({ content: \"❌ Could not send anonymous message. Please try again.\", flags: 64 });\n    }\n}\n\n// Handle /poll slash command\nasync function handlePollCommand(interaction) {\n    const question = interaction.options.getString('question');\n    const optionsString = interaction.options.getString('options');\n    const options = optionsString.split(',').map(opt => opt.trim()).filter(opt => opt.length > 0);\n    \n    if (options.length < 2) {\n        await interaction.reply({ content: \"❌ Please provide at least 2 options separated by commas.\", flags: 64 });\n        return;\n    }\n    \n    if (options.length > 10) {\n        await interaction.reply({ content: \"❌ Maximum 10 options allowed.\", flags: 64 });\n        return;\n    }\n    \n    const pollId = Math.random().toString(36).substring(7);\n    const poll = {\n        id: pollId,\n        question: question,\n        options: options,\n        votes: new Array(options.length).fill(0),\n        creator: interaction.user.id,\n        createdAt: new Date()\n    };\n    \n    activePolls.set(pollId, poll);\n    \n    let pollMessage = `**📊 POLL: ${question}**\\n\\n`;\n    options.forEach((option, index) => {\n        pollMessage += `${index + 1}. ${option}\\n`;\n    });\n    pollMessage += `\\nUse \\`/vote ${pollId} <option_number>\\` to vote`;\n    pollMessage += `\\nPoll ID: \\`${pollId}\\``;\n    \n    await interaction.reply(pollMessage);\n}\n\n// Handle /vote slash command\nasync function handleVoteCommand(interaction) {\n    const pollId = interaction.options.getString('poll_id');\n    const optionNumber = interaction.options.getInteger('option');\n    const userId = interaction.user.id;\n    \n    const poll = activePolls.get(pollId);\n    if (!poll) {\n        await interaction.reply({ content: \"❌ Poll not found.\", flags: 64 });\n        return;\n    }\n    \n    if (optionNumber < 1 || optionNumber > poll.options.length) {\n        await interaction.reply({ content: `❌ Invalid option. Choose between 1 and ${poll.options.length}.`, flags: 64 });\n        return;\n    }\n    \n    const voteKey = `${pollId}_${userId}`;\n    if (userVotes.has(voteKey)) {\n        await interaction.reply({ content: \"❌ You have already voted in this poll.\", flags: 64 });\n        return;\n    }\n    \n    poll.votes[optionNumber - 1]++;\n    userVotes.set(voteKey, optionNumber);\n    \n    await interaction.reply({ content: `✅ Your vote for \"${poll.options[optionNumber - 1]}\" has been recorded!`, flags: 64 });\n}\n\n// Handle /pollresults slash command\nasync function handlePollResultsCommand(interaction) {\n    const pollId = interaction.options.getString('poll_id');\n    \n    const poll = activePolls.get(pollId);\n    if (!poll) {\n        await interaction.reply({ content: \"❌ Poll not found.\", flags: 64 });\n        return;\n    }\n    \n    const totalVotes = poll.votes.reduce((sum, votes) => sum + votes, 0);\n    \n    let resultsMessage = `**📊 POLL RESULTS: ${poll.question}**\\n\\n`;\n    poll.options.forEach((option, index) => {\n        const votes = poll.votes[index];\n        const percentage = totalVotes > 0 ? ((votes / totalVotes) * 100).toFixed(1) : 0;\n        resultsMessage += `${index + 1}. ${option}: ${votes} votes (${percentage}%)\\n`;\n    });\n    resultsMessage += `\\nTotal votes: ${totalVotes}`;\n    resultsMessage += `\\nPoll ID: \\`${pollId}\\``;\n    \n    await interaction.reply(resultsMessage);\n}\n\n// Admin permission check\nfunction hasAdminPermissions(interaction) {\n    const member = interaction.member;\n    if (!member) return false;\n    \n    // Check if user is super admin\n    if (superAdminIds.includes(interaction.user.id)) return true;\n    \n    // Check if user has admin role\n    return member.roles.cache.has(adminRoleId) || member.permissions.has(\"Administrator\");\n}\n\n// Handle /announce slash command\nasync function handleAnnouncementCommand(interaction) {\n    // Check if user has admin permissions\n    if (!hasAdminPermissions(interaction)) {\n        await interaction.reply({ content: \"❌ You don't have permission to send announcements.\", flags: 64 });\n        return;\n    }\n    \n    const message = interaction.options.getString('message');\n    const username = interaction.user.username || \"Unknown User\";\n    \n    try {\n        const announcement = `**📢 ANNOUNCEMENT**\\n\\n${message}\\n\\n*Sent by: ${username}*`;\n        await interaction.channel.send(announcement);\n        await interaction.reply({ content: \"✅ Announcement sent!\", flags: 64 });\n        \n        // Log announcement\n        try {\n            const logChannel = await client.channels.fetch(modChannel);\n            await logChannel.send(`**📢 ANNOUNCEMENT LOG**\\nUser: ${username} (${interaction.user.id})\\nTimestamp: ${new Date().toLocaleString()}\\nChannel: #${interaction.channel.name} (${interaction.channel.id})\\nAnnouncement: ${message}`);\n        } catch (error) {\n            console.error('❌ Error logging announcement:', error.message);\n        }\n    } catch (error) {\n        console.error('❌ Error sending announcement:', error.message);\n        await interaction.reply({ content: \"❌ Could not send announcement. Please try again.\", flags: 64 });\n    }\n}\n\n// Handle PayPal command\nasync function handlePaypalCommand(interaction) {\n    const username = interaction.user.username || \"Unknown User\";\n    \n    try {\n        const paypalMessage = `\\`\\`\\`ansi\n\\u001b[32m💳 PAYMENT GATEWAY ACCESSED\n\\u001b[32m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\\u001b[32m[SYSTEM] Secure PayPal connection established\n\\u001b[32m[INFO] Payment Method: PayPal\n\\u001b[32m[LINK] https://paypal.me/DavidBarma\n\\u001b[32m[STATUS] Connection secure ✓\n\\u001b[32m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\\`\\`\\``;\n        \n        await interaction.reply({ content: paypalMessage, flags: 64 });\n        \n        // Log payment request\n        try {\n            const logChannel = await client.channels.fetch(modChannel);\n            await logChannel.send(`**💳 PAYPAL REQUEST LOG**\\nUser: ${username} (${interaction.user.id})\\nTimestamp: ${new Date().toLocaleString()}\\nChannel: #${interaction.channel.name} (${interaction.channel.id})`);\n        } catch (error) {\n            console.error('❌ Error logging PayPal request:', error.message);\n        }\n    } catch (error) {\n        console.error('❌ Error handling PayPal command:', error.message);\n        await interaction.reply({ content: \"❌ Could not retrieve payment information. Please try again.\", flags: 64 });\n    }\n}\n\n// Handle QR/UPI command\nasync function handleQRCommand(interaction) {\n    const username = interaction.user.username || \"Unknown User\";\n    \n    try {\n        const upiMessage = `\\`\\`\\`ansi\n\\u001b[32m📱 UPI PAYMENT GATEWAY\n\\u001b[32m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\\u001b[32m[SYSTEM] Secure UPI connection established\n\\u001b[32m[INFO] Payment Method: UPI/QR Code\n\\u001b[32m[UPI ID] davidbarma19-4@okicici\n\\u001b[32m[STATUS] Connection secure ✓\n\\u001b[32m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\\`\\`\\``;\n        \n        await interaction.reply({ content: upiMessage, flags: 64 });\n        \n        // Log UPI request\n        try {\n            const logChannel = await client.channels.fetch(modChannel);\n            await logChannel.send(`**📱 UPI REQUEST LOG**\\nUser: ${username} (${interaction.user.id})\\nTimestamp: ${new Date().toLocaleString()}\\nChannel: #${interaction.channel.name} (${interaction.channel.id})`);\n        } catch (error) {\n            console.error('❌ Error logging UPI request:', error.message);\n        }\n    } catch (error) {\n        console.error('❌ Error handling QR command:', error.message);\n        await interaction.reply({ content: \"❌ Could not retrieve payment information. Please try again.\", flags: 64 });\n    }\n}\n\n// Handle status command\nasync function handleStatusCommand(interaction) {\n    await interaction.reply(`✅ Bot is online!\\n🕐 Uptime: ${Math.floor(process.uptime())} seconds\\n📡 Ping: ${client.ws.ping}ms`);\n}\n\n// Handle clear command\nasync function handleClearCommand(interaction) {\n    // Check if user has admin permissions\n    if (!hasAdminPermissions(interaction)) {\n        await interaction.reply({ content: \"❌ You don't have permission to clear the channel.\", flags: 64 });\n        return;\n    }\n\n    try {\n        await clearChannelAndStartup();\n        await interaction.reply({ content: \"✅ Anonymous channel cleared and restarted!\", flags: 64 });\n    } catch (error) {\n        console.error('❌ Error clearing channel:', error.message);\n        await interaction.reply({ content: \"❌ Could not clear channel. Please try again.\", flags: 64 });\n    }\n}\n\n// Handle /sell command - List item for auction\nasync function handleSellCommand(interaction) {\n    const item = interaction.options.getString('item');\n    const price = interaction.options.getInteger('price');\n    const image = interaction.options.getAttachment('image');\n    const userId = interaction.user.id;\n    const username = interaction.user.username || \"Unknown User\";\n\n    // Auto-approve super admins if not already approved\n    if (superAdminIds.includes(userId)) {\n        approvedUsers.add(userId);\n    }\n\n    // Check if user has already submitted application\n    if (!approvedUsers.has(userId)) {\n        await interaction.reply({ \n            content: `\\`\\`\\`ansi\n\\u001b[31m[ACCESS_DENIED] >> UNAUTHORIZED TERMINAL ACCESS\n\\u001b[31m[ERROR] >> User not verified for marketplace operations\n\\u001b[31m[SYSTEM] >> Application required for secure transactions\n\\u001b[31m[CMD] >> Execute: /apply with real credentials\n\\u001b[31m[WARNING] >> Fake info = permanent ban from all networks\n\\`\\`\\``, \n            flags: 64 \n        });\n        return;\n    }\n\n    // Validate and process image\n    if (!image || !image.contentType?.startsWith('image/')) {\n        await interaction.reply({ \n            content: `\\`\\`\\`ansi\n\\u001b[31m[ERROR] >> Invalid image file\n\\u001b[31m[REQUIRED] >> JPG, PNG, GIF formats only\n\\u001b[31m[ACTION] >> Upload valid image and try again\n\\`\\`\\``, \n            flags: 64 \n        });\n        return;\n    }\n\n    // Show processing message\n    await interaction.deferReply({ flags: 64 });\n\n    // Automatically resize image to 150x150\n    const resizedImageBuffer = await resizeImageTo150x150(image.url);\n    if (!resizedImageBuffer) {\n        await interaction.editReply({ \n            content: `\\`\\`\\`ansi\n\\u001b[31m[ERROR] >> Failed to process image\n\\u001b[31m[ACTION] >> Try uploading a different image\n\\`\\`\\``, \n            flags: 64 \n        });\n        return;\n    }\n\n    try {\n        // Generate auction ID\n        const auctionId = Math.random().toString(36).substring(7).toUpperCase();\n        const hackerId = generateHackerUserId();\n\n        // Create auction data\n        const auction = {\n            id: auctionId,\n            hackerId: hackerId,\n            sellerId: userId,\n            sellerName: username,\n            item: item,\n            startingPrice: price,\n            currentPrice: price,\n            highestBidder: null,\n            bids: [],\n            imageUrl: image.url, // Keep original URL for now\n            resizedImageBuffer: resizedImageBuffer, // Store resized buffer\n            createdAt: new Date(),\n            endTime: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours\n            isActive: true\n        };\n\n        activeAuctions.set(auctionId, auction);\n\n        // Send hacker-style auction listing\n        const auctionMessage = `\\`\\`\\`ansi\n\\u001b[32m[MARKETPLACE] >> NEW ITEM LISTED FOR AUCTION\n\\u001b[32m[SELLER] :: ${hackerId}\n\\u001b[32m[ITEM] >> ${item}\n\\u001b[32m[START_PRICE] >> $${price}\n\\u001b[32m[CURRENT_BID] >> $${price}\n\\u001b[32m[AUCTION_ID] >> ${auctionId}\n\\u001b[32m[STATUS] >> ACTIVE :: 24H TIMER INITIATED\n\\u001b[32m[SECURITY] >> VERIFIED SELLER :: SAFE TRANSACTION\n\\u001b[32m\n\\u001b[32m┌───────────────────────────────────────────────────────────────┐\n\\u001b[32m│  ⚡ PLACE BID: /bid ${auctionId} <amount>                        │\n\\u001b[32m└───────────────────────────────────────────────────────────────┘\n\\u001b[32m[WARNING] >> Must be verified to bid\n\\`\\`\\``;\n\n        // Send to auction channel\n        const auctionChannelObj = await client.channels.fetch(auctionChannel || anonymousChannel);\n        const sentMessage = await auctionChannelObj.send({\n            content: auctionMessage,\n            files: [{\n                attachment: resizedImageBuffer,\n                name: `auction_${auctionId}_150x150.jpg`,\n                description: `Resized auction image for ${item}`\n            }]\n        });\n\n        auction.messageId = sentMessage.id;\n\n        await interaction.editReply({ \n            content: `\\`\\`\\`ansi\n\\u001b[32m[SUCCESS] >> Item listed successfully\n\\u001b[32m[AUCTION_ID] >> ${auctionId}\n\\u001b[32m[DURATION] >> 24 hours\n\\u001b[32m[STATUS] >> Live auction started\n\\u001b[32m[IMAGE] >> Auto-resized to 150x150 pixels\n\\`\\`\\``, \n            flags: 64 \n        });\n\n        // Log to mod channel\n        try {\n            const logChannel = await client.channels.fetch(modChannel);\n            await logChannel.send(`**💰 NEW AUCTION CREATED**\\nSeller: ${username} (${userId})\\nItem: ${item}\\nStarting Price: $${price}\\nAuction ID: ${auctionId}\\nTimestamp: ${new Date().toLocaleString()}`);\n        } catch (error) {\n            console.error('❌ Error logging auction creation:', error.message);\n        }\n\n    } catch (error) {\n        console.error('❌ Error handling sell command:', error.message);\n        await interaction.reply({ content: \"❌ Could not create auction. Please try again.\", flags: 64 });\n    }\n}\n\n// Handle /bid command\nasync function handleBidCommand(interaction) {\n    const auctionId = interaction.options.getString('auction_id').toUpperCase();\n    const bidAmount = interaction.options.getInteger('amount');\n    const userId = interaction.user.id;\n    const username = interaction.user.username || \"Unknown User\";\n\n    // Auto-approve super admins if not already approved\n    if (superAdminIds.includes(userId)) {\n        approvedUsers.add(userId);\n    }\n\n    // Check if user is verified\n    if (!approvedUsers.has(userId)) {\n        await interaction.reply({ \n            content: `\\`\\`\\`ansi\n\\u001b[31m[ACCESS_DENIED] >> UNAUTHORIZED BID ATTEMPT\n\\u001b[31m[ERROR] >> User not verified for bidding operations\n\\u001b[31m[SYSTEM] >> Submit application: /apply\n\\u001b[31m[WARNING] >> Only verified users can participate\n\\`\\`\\``, \n            flags: 64 \n        });\n        return;\n    }\n\n    const auction = activeAuctions.get(auctionId);\n    if (!auction || !auction.isActive) {\n        await interaction.reply({ \n            content: `\\`\\`\\`ansi\n\\u001b[31m[ERROR] >> Auction not found or inactive\n\\u001b[31m[AUCTION_ID] >> ${auctionId}\n\\u001b[31m[STATUS] >> TERMINATED\n\\`\\`\\``, \n            flags: 64 \n        });\n        return;\n    }\n\n    // Check if bid is higher than current price\n    if (bidAmount <= auction.currentPrice) {\n        await interaction.reply({ \n            content: `\\`\\`\\`ansi\n\\u001b[31m[BID_REJECTED] >> Amount too low\n\\u001b[31m[CURRENT_BID] >> $${auction.currentPrice}\n\\u001b[31m[MINIMUM_BID] >> $${auction.currentPrice + 1}\n\\`\\`\\``, \n            flags: 64 \n        });\n        return;\n    }\n\n    // Check if user is trying to bid on their own auction\n    if (auction.sellerId === userId) {\n        await interaction.reply({ \n            content: `\\`\\`\\`ansi\n\\u001b[31m[ERROR] >> Cannot bid on your own auction\n\\u001b[31m[SECURITY] >> Self-bidding prohibited\n\\`\\`\\``, \n            flags: 64 \n        });\n        return;\n    }\n\n    try {\n        // Update auction with new bid\n        const hackerId = generateHackerUserId();\n        auction.currentPrice = bidAmount;\n        auction.highestBidder = userId;\n        auction.highestBidderName = username;\n        auction.bids.push({\n            userId: userId,\n            username: username,\n            hackerId: hackerId,\n            amount: bidAmount,\n            timestamp: new Date()\n        });\n\n        // Update auction message\n        const updatedMessage = `\\`\\`\\`ansi\n\\u001b[32m[MARKETPLACE] >> AUCTION UPDATE\n\\u001b[32m[SELLER] :: ${auction.hackerId}\n\\u001b[32m[ITEM] >> ${auction.item}\n\\u001b[32m[START_PRICE] >> $${auction.startingPrice}\n\\u001b[32m[CURRENT_BID] >> $${bidAmount}\n\\u001b[32m[HIGHEST_BIDDER] :: ${hackerId}\n\\u001b[32m[AUCTION_ID] >> ${auctionId}\n\\u001b[32m[STATUS] >> ACTIVE :: ${Math.floor((auction.endTime - new Date()) / (1000 * 60 * 60))}H LEFT\n\\u001b[32m\n\\u001b[32m┌───────────────────────────────────────────────────────────────┐\n\\u001b[32m│  ⚡ OUTBID: /bid ${auctionId} <amount>                           │\n\\u001b[32m└───────────────────────────────────────────────────────────────┘\n\\u001b[32m[WARNING] >> Must be verified to bid\n\\`\\`\\``;\n\n        // Update message in auction channel\n        try {\n            const auctionChannelObj = await client.channels.fetch(auctionChannel || anonymousChannel);\n            const message = await auctionChannelObj.messages.fetch(auction.messageId);\n            await message.edit(updatedMessage);\n        } catch (error) {\n            console.error('❌ Error updating auction message:', error.message);\n        }\n\n        await interaction.reply({ \n            content: `\\`\\`\\`ansi\n\\u001b[32m[BID_ACCEPTED] >> Your bid has been placed\n\\u001b[32m[AMOUNT] >> $${bidAmount}\n\\u001b[32m[STATUS] >> Highest bidder\n\\u001b[32m[AUCTION_ID] >> ${auctionId}\n\\`\\`\\``, \n            flags: 64 \n        });\n\n        // Log to mod channel\n        try {\n            const logChannel = await client.channels.fetch(modChannel);\n            await logChannel.send(`**💰 NEW BID PLACED**\\nBidder: ${username} (${userId})\\nAuction ID: ${auctionId}\\nBid Amount: $${bidAmount}\\nItem: ${auction.item}\\nTimestamp: ${new Date().toLocaleString()}`);\n        } catch (error) {\n            console.error('❌ Error logging bid:', error.message);\n        }\n\n    } catch (error) {\n        console.error('❌ Error handling bid command:', error.message);\n        await interaction.reply({ content: \"❌ Could not place bid. Please try again.\", flags: 64 });\n    }\n}\n\n// Handle /apply command\nasync function handleApplyCommand(interaction) {\n    const fullname = interaction.options.getString('fullname');\n    const idNumber = interaction.options.getString('id_number');\n    const profilePicture = interaction.options.getAttachment('profile_picture');\n    const userId = interaction.user.id;\n    const username = interaction.user.username || \"Unknown User\";\n\n    // Check if user already has pending application\n    if (pendingApplications.has(userId)) {\n        await interaction.reply({ \n            content: `\\`\\`\\`ansi\n\\u001b[33m[PENDING] >> Application already submitted\n\\u001b[33m[STATUS] >> Awaiting admin approval\n\\u001b[33m[WARNING] >> Do not submit duplicate applications\n\\`\\`\\``, \n            flags: 64 \n        });\n        return;\n    }\n\n    // Check if user is already approved\n    if (approvedUsers.has(userId)) {\n        await interaction.reply({ \n            content: `\\`\\`\\`ansi\n\\u001b[32m[VERIFIED] >> You are already approved\n\\u001b[32m[ACCESS] >> Full marketplace permissions\n\\u001b[32m[STATUS] >> Can sell and bid freely\n\\`\\`\\``, \n            flags: 64 \n        });\n        return;\n    }\n\n    try {\n        // Generate application ID\n        const applicationId = Math.random().toString(36).substring(7).toUpperCase();\n\n        // Store application\n        const application = {\n            id: applicationId,\n            userId: userId,\n            username: username,\n            fullname: fullname,\n            idNumber: idNumber,\n            profilePictureUrl: profilePicture.url,\n            createdAt: new Date(),\n            status: 'pending'\n        };\n\n        pendingApplications.set(applicationId, application);\n        userApplications.set(userId, applicationId);\n\n        // Send application to approval channel with buttons\n        const approvalChannel = await client.channels.fetch(\"1406725485831913545\");\n        const applicationMessage = `\\`\\`\\`ansi\n\\u001b[33m[NEW_APPLICATION] >> VERIFICATION REQUEST\n\\u001b[33m[USERNAME] :: ${username}\n\\u001b[33m[DISCORD_ID] :: ${userId}\n\\u001b[33m[FULL_NAME] :: ${fullname}\n\\u001b[33m[ID_NUMBER] :: ${idNumber}\n\\u001b[33m[APP_ID] :: ${applicationId}\n\\u001b[33m[TIMESTAMP] :: ${new Date().toLocaleString()}\n\\u001b[33m[WARNING] >> Verify all info before approval\n\\`\\`\\``;\n\n        // Create approval buttons\n        const approvalButtons = new ActionRowBuilder()\n            .addComponents(\n                new ButtonBuilder()\n                    .setCustomId(`approve_${applicationId}`)\n                    .setLabel('✅ APPROVE')\n                    .setStyle(ButtonStyle.Success),\n                new ButtonBuilder()\n                    .setCustomId(`deny_${applicationId}`)\n                    .setLabel('❌ DENY')\n                    .setStyle(ButtonStyle.Danger)\n            );\n\n        // Resize profile picture to 150x150\n        const resizedProfileBuffer = await resizeImageTo150x150(profilePicture.url);\n        \n        await approvalChannel.send({\n            content: applicationMessage,\n            files: resizedProfileBuffer ? [{\n                attachment: resizedProfileBuffer,\n                name: `profile_${applicationId}_150x150.jpg`,\n                description: `Resized profile picture for ${fullname}`\n            }] : [profilePicture.url],\n            components: [approvalButtons]\n        });\n\n        await interaction.reply({ \n            content: `\\`\\`\\`ansi\n\\u001b[32m[APPLICATION_SUBMITTED] >> Verification request sent\n\\u001b[32m[APP_ID] >> ${applicationId}\n\\u001b[32m[STATUS] >> Pending admin review\n\\u001b[32m[WARNING] >> False info = permanent ban\n\\u001b[32m[WAIT] >> Check back later for approval status\n\\`\\`\\``, \n            flags: 64 \n        });\n\n        // Log application\n        try {\n            const logChannel = await client.channels.fetch(modChannel);\n            await logChannel.send(`**📋 NEW APPLICATION SUBMITTED**\\nUser: ${username} (${userId})\\nFull Name: ${fullname}\\nID Number: ${idNumber}\\nApplication ID: ${applicationId}\\nTimestamp: ${new Date().toLocaleString()}`);\n        } catch (error) {\n            console.error('❌ Error logging application:', error.message);\n        }\n\n    } catch (error) {\n        console.error('❌ Error handling apply command:', error.message);\n        await interaction.reply({ content: \"❌ Could not submit application. Please try again.\", flags: 64 });\n    }\n}\n\n// Handle button interactions\nasync function handleButtonInteraction(interaction) {\n    try {\n        // Acknowledge the interaction immediately to prevent timeout\n        await interaction.deferUpdate();\n        \n        const customId = interaction.customId;\n        const adminUsername = interaction.user.username || \"Unknown Admin\";\n\n        // Check if user has admin permissions\n        if (!hasAdminPermissions(interaction)) {\n            await interaction.followUp({ content: \"❌ You don't have permission to approve applications.\", flags: 64 });\n            return;\n        }\n\n        if (customId.startsWith('approve_') || customId.startsWith('deny_')) {\n            const action = customId.startsWith('approve_') ? 'approve' : 'deny';\n            const applicationId = customId.split('_')[1];\n\n            const application = pendingApplications.get(applicationId);\n            if (!application) {\n                await interaction.followUp({ content: \"❌ Application not found or already processed.\", flags: 64 });\n                return;\n            }\n\n            try {\n                if (action === 'approve') {\n                // Approve user\n                approvedUsers.add(application.userId);\n                application.status = 'approved';\n                application.reviewedBy = interaction.user.id;\n                application.reviewedAt = new Date();\n\n                // Remove from pending\n                pendingApplications.delete(applicationId);\n\n                // Notify user (if possible)\n                try {\n                    const user = await client.users.fetch(application.userId);\n                    await user.send(`\\`\\`\\`ansi\n\\u001b[32m[APPROVED] >> Your application has been approved\n\\u001b[32m[STATUS] >> Full marketplace access granted\n\\u001b[32m[PERMISSIONS] >> Can now sell and bid\n\\u001b[32m[COMMANDS] >> /sell and /bid now available\n\\u001b[32m[WARNING] >> Follow all marketplace rules\n\\`\\`\\``);\n                } catch (error) {\n                    console.log('Could not DM user about approval');\n                }\n\n                // Update the message with approval status\n                const updatedMessage = `\\`\\`\\`ansi\n\\u001b[32m[APPROVED] >> APPLICATION VERIFIED ✅\n\\u001b[32m[USERNAME] :: ${application.username}\n\\u001b[32m[DISCORD_ID] :: ${application.userId}\n\\u001b[32m[FULL_NAME] :: ${application.fullname}\n\\u001b[32m[ID_NUMBER] :: ${application.idNumber}\n\\u001b[32m[APP_ID] :: ${applicationId}\n\\u001b[32m[APPROVED_BY] :: ${adminUsername}\n\\u001b[32m[TIMESTAMP] :: ${new Date().toLocaleString()}\n\\u001b[32m[STATUS] >> FULL MARKETPLACE ACCESS GRANTED\n\\`\\`\\``;\n\n                await interaction.editReply({ \n                    content: updatedMessage, \n                    components: [] // Remove buttons\n                });\n\n                } else {\n                    // Deny user\n                application.status = 'denied';\n                application.reviewedBy = interaction.user.id;\n                application.reviewedAt = new Date();\n\n                // Remove from pending\n                pendingApplications.delete(applicationId);\n                userApplications.delete(application.userId);\n\n                // Notify user (if possible)\n                try {\n                    const user = await client.users.fetch(application.userId);\n                    await user.send(`\\`\\`\\`ansi\n\\u001b[31m[DENIED] >> Your application has been denied\n\\u001b[31m[REASON] >> Information verification failed\n\\u001b[31m[STATUS] >> No marketplace access\n\\u001b[31m[ACTION] >> Resubmit with valid information\n\\`\\`\\``);\n                } catch (error) {\n                    console.log('Could not DM user about denial');\n                }\n\n                // Update the message with denial status\n                const updatedMessage = `\\`\\`\\`ansi\n\\u001b[31m[DENIED] >> APPLICATION REJECTED ❌\n\\u001b[31m[USERNAME] :: ${application.username}\n\\u001b[31m[DISCORD_ID] :: ${application.userId}\n\\u001b[31m[FULL_NAME] :: ${application.fullname}\n\\u001b[31m[ID_NUMBER] :: ${application.idNumber}\n\\u001b[31m[APP_ID] :: ${applicationId}\n\\u001b[31m[DENIED_BY] :: ${adminUsername}\n\\u001b[31m[TIMESTAMP] :: ${new Date().toLocaleString()}\n\\u001b[31m[REASON] >> Information verification failed\n\\`\\`\\``;\n\n                await interaction.editReply({ \n                    content: updatedMessage, \n                    components: [] // Remove buttons\n                });\n                }\n\n                // Log admin action\n                try {\n                    const logChannel = await client.channels.fetch(modChannel);\n                    await logChannel.send(`**⚖️ APPLICATION ${action.toUpperCase()}**\\nAdmin: ${adminUsername} (${interaction.user.id})\\nUser: ${application.username} (${application.userId})\\nApplication ID: ${applicationId}\\nAction: ${action}\\nTimestamp: ${new Date().toLocaleString()}`);\n                } catch (error) {\n                    console.error('❌ Error logging admin action:', error.message);\n                }\n\n            } catch (error) {\n                console.error('❌ Error handling button interaction:', error.message);\n                try {\n                    await interaction.followUp({ content: \"❌ Could not process application. Please try again.\", flags: 64 });\n                } catch (followUpError) {\n                    console.error('❌ Could not send follow-up message:', followUpError.message);\n                }\n            }\n        }\n    } catch (mainError) {\n        console.error('❌ Error in button interaction handler:', mainError.message);\n    }\n}\n\n// Handle /auctions command\nasync function handleAuctionsCommand(interaction) {\n    if (activeAuctions.size === 0) {\n        await interaction.reply({ \n            content: `\\`\\`\\`ansi\n\\u001b[33m[MARKETPLACE] >> No active auctions\n\\u001b[33m[STATUS] >> Market currently empty\n\\u001b[33m[INFO] >> Use /sell to list items\n\\`\\`\\``, \n            flags: 64 \n        });\n        return;\n    }\n\n    let auctionsList = `\\`\\`\\`ansi\n\\u001b[32m[ACTIVE_AUCTIONS] >> MARKETPLACE STATUS\n\\u001b[32m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n`;\n\n    for (const [auctionId, auction] of activeAuctions) {\n        if (auction.isActive) {\n            const timeLeft = Math.floor((auction.endTime - new Date()) / (1000 * 60 * 60));\n            auctionsList += `\\u001b[32m[${auctionId}] ${auction.item} - $${auction.currentPrice} (${timeLeft}h left)\\n`;\n        }\n    }\n\n    auctionsList += `\\u001b[32m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\\u001b[32m[CMD] >> /bid <auction_id> <amount> to bid\n\\`\\`\\``;\n\n    await interaction.reply({ content: auctionsList, flags: 64 });\n}\n\n// Error handling\nprocess.on('unhandledRejection', (reason, promise) => {\n    console.error('❌ Unhandled Rejection at:', promise, 'reason:', reason);\n});\n\nprocess.on('uncaughtException', (error) => {\n    console.error('❌ Uncaught Exception:', error);\n    process.exit(1);\n});\n\n// Start Express server for health checks\napp.get('/', (req, res) => {\n    res.json({ \n        name: 'Discord Anonymous Bot',\n        status: 'running',\n        uptime: process.uptime(),\n        description: 'Discord bot with anonymous messaging and community features',\n        endpoints: {\n            health: '/health',\n            root: '/'\n        }\n    });\n});\n\napp.get('/health', (req, res) => {\n    res.json({ status: 'ok', uptime: process.uptime() });\n});\n\napp.listen(8000, '0.0.0.0', () => {\n    console.log('🌐 Health check server running on port 8000');\n});\n\n// Login to Discord\nif (token) {\n    client.login(token).catch(error => {\n        console.error('❌ Error logging in to Discord:', error);\n        console.log('💡 Please check your DISCORD_BOT_TOKEN is valid');\n        console.log('🔗 Get your token from: https://discord.com/developers/applications');\n    });\n} else {\n    console.log('🤖 Bot ready to connect - please provide DISCORD_BOT_TOKEN');\n    console.log('🔗 Get your token from: https://discord.com/developers/applications');\n}","size_bytes":62679},"replit.md":{"content":"# Discord Anonymous Bot\n\n## Overview\n\nThis is a comprehensive Discord bot that provides anonymous messaging capabilities with advanced security and moderation features. The bot is fully operational and includes terminal-style messaging, comprehensive logging, profanity filtering, polls, payment commands, and admin controls. Built with Discord.js v14 and PostgreSQL database integration.\n\n## Recent Changes (August 18, 2025)\n\n✓ Successfully migrated from Replit Agent to Replit environment\n✓ PostgreSQL database created and configured with all required tables\n✓ All Node.js dependencies installed and properly configured\n✓ Database migrations generated and applied (8 tables)\n✓ Express health check server running on port 8000\n✓ Discord bot token configured and bot connected as PCRP ANON#5146\n✓ Web interface with status endpoints for monitoring\n✓ All security features and moderation tools operational\n✓ Complete architecture validated and working\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Backend Architecture\n- **Framework**: Node.js with Express.js server\n- **Discord Integration**: Discord.js v14 with Gateway Intents and Partials for comprehensive Discord API access\n- **Database ORM**: Drizzle ORM for type-safe database operations\n- **Database Connection**: Neon serverless PostgreSQL with connection pooling\n- **Module System**: ES6 modules with modern import/export syntax\n\n### Authentication & Authorization\n- **Role-based Access Control**: Multiple Discord roles control different functionalities:\n  - Allowed Role: Can send anonymous messages\n  - Admin Role: Can send announcements and manage system\n  - Moderator permissions embedded in user schema\n- **Anonymous User Management**: UUID-based anonymous user identification system\n- **Security Logging**: Comprehensive audit trail for all user actions and security events\n\n### Data Storage Architecture\n- **Database Schema**: Well-structured PostgreSQL schema with the following entities:\n  - Users: Discord user data with role permissions\n  - Anonymous Messages: Message tracking with author correlation\n  - Security Logs: Audit trail for security events\n  - Polls: Community voting system with options\n  - Poll Votes: Individual vote tracking\n  - Rate Limits: Anti-spam protection\n  - Applications: User application system\n  - Auctions: Marketplace functionality\n- **Storage Abstraction**: Interface-based storage layer allowing for future database migrations\n- **Connection Management**: Pooled connections for optimal performance\n\n### Content Moderation System\n- **Profanity Filter**: Comprehensive blocked words list covering multiple languages\n- **Rate Limiting**: User-based message frequency controls\n- **Channel-based Routing**: Dedicated channels for different message types (anonymous, applications, auctions)\n- **Logging and Monitoring**: All moderation actions are logged for review\n\n### Avatar System\n- **Anonymous Avatars**: Unicode emoji-based avatar generation using deterministic hashing\n- **Terminal Avatars**: Colored terminal representations for enhanced user experience\n- **Seed-based Generation**: Consistent avatar assignment based on user identifiers\n\n## External Dependencies\n\n### Discord API\n- **Discord.js**: Primary Discord API wrapper for bot functionality\n- **Gateway Intents**: Real-time event handling for messages, guilds, and user interactions\n- **Slash Commands**: Modern Discord command interface\n- **REST API**: Direct Discord API access for advanced operations\n\n### Database Services\n- **Neon Database**: Serverless PostgreSQL hosting with WebSocket support\n- **Connection Pooling**: pg library for efficient database connections\n- **WebSocket Configuration**: ws library for Neon's serverless architecture\n\n### Development Tools\n- **Environment Management**: dotenv for configuration management\n- **UUID Generation**: uuid library for unique identifier creation\n- **Type Safety**: TypeScript integration with Drizzle ORM schemas\n\n### Security & Monitoring\n- **Rate Limiting**: Built-in anti-spam protection\n- **Audit Logging**: Comprehensive security event tracking\n- **Content Filtering**: Multi-language profanity detection system","size_bytes":4222},"server/db.ts":{"content":"import { Pool, neonConfig } from '@neondatabase/serverless';\nimport { drizzle } from 'drizzle-orm/neon-serverless';\nimport ws from \"ws\";\nimport * as schema from \"../shared/schema\";\n\nneonConfig.webSocketConstructor = ws;\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\n    \"DATABASE_URL must be set. Did you forget to provision a database?\",\n  );\n}\n\nexport const pool = new Pool({ connectionString: process.env.DATABASE_URL });\nexport const db = drizzle({ client: pool, schema });\n","size_bytes":485},"server/storage.ts":{"content":"import { users, anonymousMessages, securityLogs, polls, pollVotes, rateLimits, applications, auctions, type User, type InsertUser, type AnonymousMessage, type InsertAnonymousMessage, type SecurityLog, type InsertSecurityLog, type Poll, type InsertPoll, type PollVote, type InsertPollVote, type RateLimit, type InsertRateLimit, type Application, type InsertApplication, type Auction, type InsertAuction } from \"../shared/schema.js\";\nimport { db } from \"./db.js\";\nimport { eq, desc, and } from \"drizzle-orm\";\n\nexport interface IStorage {\n  // User operations\n  getUser(discordId: string): Promise<User | undefined>;\n  getUserByUsername(username: string): Promise<User | undefined>;\n  createUser(insertUser: InsertUser): Promise<User>;\n  updateUser(discordId: string, updates: Partial<User>): Promise<User | undefined>;\n  \n  // Anonymous message operations\n  createAnonymousMessage(message: InsertAnonymousMessage): Promise<AnonymousMessage>;\n  getAnonymousMessage(messageId: string): Promise<AnonymousMessage | undefined>;\n  getAnonymousMessagesByUser(authorId: string): Promise<AnonymousMessage[]>;\n  \n  // Security log operations\n  createSecurityLog(log: InsertSecurityLog): Promise<SecurityLog>;\n  getSecurityLogs(userId?: string): Promise<SecurityLog[]>;\n  \n  // Poll operations\n  createPoll(poll: InsertPoll): Promise<Poll>;\n  getPoll(pollId: string): Promise<Poll | undefined>;\n  getActivePolls(): Promise<Poll[]>;\n  closePoll(pollId: string): Promise<void>;\n  \n  // Poll vote operations\n  createPollVote(vote: InsertPollVote): Promise<PollVote>;\n  getPollVotes(pollId: string): Promise<PollVote[]>;\n  getUserPollVote(pollId: string, userId: string): Promise<PollVote | undefined>;\n  \n  // Rate limit operations\n  getRateLimit(userId: string): Promise<RateLimit | undefined>;\n  updateRateLimit(userId: string, updates: Partial<RateLimit>): Promise<RateLimit>;\n  createRateLimit(rateLimit: InsertRateLimit): Promise<RateLimit>;\n  \n  // Application operations\n  createApplication(application: InsertApplication): Promise<Application>;\n  getApplication(applicationId: string): Promise<Application | undefined>;\n  getPendingApplications(): Promise<Application[]>;\n  updateApplication(applicationId: string, updates: Partial<Application>): Promise<Application | undefined>;\n  \n  // Auction operations\n  createAuction(auction: InsertAuction): Promise<Auction>;\n  getAuction(auctionId: string): Promise<Auction | undefined>;\n  getActiveAuctions(): Promise<Auction[]>;\n  updateAuction(auctionId: string, updates: Partial<Auction>): Promise<Auction | undefined>;\n}\n\nexport class DatabaseStorage implements IStorage {\n  // User operations\n  async getUser(discordId: string): Promise<User | undefined> {\n    const [user] = await db.select().from(users).where(eq(users.discordId, discordId));\n    return user || undefined;\n  }\n\n  async getUserByUsername(username: string): Promise<User | undefined> {\n    const [user] = await db.select().from(users).where(eq(users.username, username));\n    return user || undefined;\n  }\n\n  async createUser(insertUser: InsertUser): Promise<User> {\n    const [user] = await db\n      .insert(users)\n      .values(insertUser)\n      .returning();\n    return user;\n  }\n\n  async updateUser(discordId: string, updates: Partial<User>): Promise<User | undefined> {\n    const [user] = await db\n      .update(users)\n      .set({ ...updates, updatedAt: new Date() })\n      .where(eq(users.discordId, discordId))\n      .returning();\n    return user || undefined;\n  }\n\n  // Anonymous message operations\n  async createAnonymousMessage(message: InsertAnonymousMessage): Promise<AnonymousMessage> {\n    const [msg] = await db\n      .insert(anonymousMessages)\n      .values(message)\n      .returning();\n    return msg;\n  }\n\n  async getAnonymousMessage(messageId: string): Promise<AnonymousMessage | undefined> {\n    const [message] = await db\n      .select()\n      .from(anonymousMessages)\n      .where(eq(anonymousMessages.messageId, messageId));\n    return message || undefined;\n  }\n\n  async getAnonymousMessagesByUser(authorId: string): Promise<AnonymousMessage[]> {\n    return await db\n      .select()\n      .from(anonymousMessages)\n      .where(eq(anonymousMessages.authorId, authorId))\n      .orderBy(desc(anonymousMessages.createdAt));\n  }\n\n  // Security log operations\n  async createSecurityLog(log: InsertSecurityLog): Promise<SecurityLog> {\n    const [secLog] = await db\n      .insert(securityLogs)\n      .values(log)\n      .returning();\n    return secLog;\n  }\n\n  async getSecurityLogs(userId?: string): Promise<SecurityLog[]> {\n    const query = db.select().from(securityLogs);\n    if (userId) {\n      return await query.where(eq(securityLogs.userId, userId)).orderBy(desc(securityLogs.createdAt));\n    }\n    return await query.orderBy(desc(securityLogs.createdAt));\n  }\n\n  // Poll operations\n  async createPoll(poll: InsertPoll): Promise<Poll> {\n    const [newPoll] = await db\n      .insert(polls)\n      .values(poll)\n      .returning();\n    return newPoll;\n  }\n\n  async getPoll(pollId: string): Promise<Poll | undefined> {\n    const [poll] = await db\n      .select()\n      .from(polls)\n      .where(eq(polls.pollId, pollId));\n    return poll || undefined;\n  }\n\n  async getActivePolls(): Promise<Poll[]> {\n    return await db\n      .select()\n      .from(polls)\n      .where(eq(polls.isActive, true))\n      .orderBy(desc(polls.createdAt));\n  }\n\n  async closePoll(pollId: string): Promise<void> {\n    await db\n      .update(polls)\n      .set({ isActive: false, closedAt: new Date() })\n      .where(eq(polls.pollId, pollId));\n  }\n\n  // Poll vote operations\n  async createPollVote(vote: InsertPollVote): Promise<PollVote> {\n    const [newVote] = await db\n      .insert(pollVotes)\n      .values(vote)\n      .returning();\n    return newVote;\n  }\n\n  async getPollVotes(pollId: string): Promise<PollVote[]> {\n    return await db\n      .select()\n      .from(pollVotes)\n      .where(eq(pollVotes.pollId, pollId))\n      .orderBy(desc(pollVotes.createdAt));\n  }\n\n  async getUserPollVote(pollId: string, userId: string): Promise<PollVote | undefined> {\n    const [vote] = await db\n      .select()\n      .from(pollVotes)\n      .where(and(eq(pollVotes.pollId, pollId), eq(pollVotes.userId, userId)));\n    return vote || undefined;\n  }\n\n  // Rate limit operations\n  async getRateLimit(userId: string): Promise<RateLimit | undefined> {\n    const [rateLimit] = await db\n      .select()\n      .from(rateLimits)\n      .where(eq(rateLimits.userId, userId));\n    return rateLimit || undefined;\n  }\n\n  async updateRateLimit(userId: string, updates: Partial<RateLimit>): Promise<RateLimit> {\n    const [rateLimit] = await db\n      .update(rateLimits)\n      .set({ ...updates, updatedAt: new Date() })\n      .where(eq(rateLimits.userId, userId))\n      .returning();\n    return rateLimit;\n  }\n\n  async createRateLimit(rateLimit: InsertRateLimit): Promise<RateLimit> {\n    const [newRateLimit] = await db\n      .insert(rateLimits)\n      .values(rateLimit)\n      .returning();\n    return newRateLimit;\n  }\n\n  // Application operations\n  async createApplication(application: InsertApplication): Promise<Application> {\n    const [app] = await db\n      .insert(applications)\n      .values(application)\n      .returning();\n    return app;\n  }\n\n  async getApplication(applicationId: string): Promise<Application | undefined> {\n    const [application] = await db\n      .select()\n      .from(applications)\n      .where(eq(applications.applicationId, applicationId));\n    return application || undefined;\n  }\n\n  async getPendingApplications(): Promise<Application[]> {\n    return await db\n      .select()\n      .from(applications)\n      .where(eq(applications.status, 'pending'))\n      .orderBy(desc(applications.createdAt));\n  }\n\n  async updateApplication(applicationId: string, updates: Partial<Application>): Promise<Application | undefined> {\n    const [application] = await db\n      .update(applications)\n      .set(updates)\n      .where(eq(applications.applicationId, applicationId))\n      .returning();\n    return application || undefined;\n  }\n\n  // Auction operations\n  async createAuction(auction: InsertAuction): Promise<Auction> {\n    const [newAuction] = await db\n      .insert(auctions)\n      .values(auction)\n      .returning();\n    return newAuction;\n  }\n\n  async getAuction(auctionId: string): Promise<Auction | undefined> {\n    const [auction] = await db\n      .select()\n      .from(auctions)\n      .where(eq(auctions.auctionId, auctionId));\n    return auction || undefined;\n  }\n\n  async getActiveAuctions(): Promise<Auction[]> {\n    return await db\n      .select()\n      .from(auctions)\n      .where(eq(auctions.isActive, true))\n      .orderBy(desc(auctions.createdAt));\n  }\n\n  async updateAuction(auctionId: string, updates: Partial<Auction>): Promise<Auction | undefined> {\n    const [auction] = await db\n      .update(auctions)\n      .set(updates)\n      .where(eq(auctions.auctionId, auctionId))\n      .returning();\n    return auction || undefined;\n  }\n}\n\nexport const storage = new DatabaseStorage();\n","size_bytes":9007},"shared/schema.ts":{"content":"import { pgTable, serial, text, timestamp, integer, boolean, varchar } from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\n\n// Users table for Discord user data\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  discordId: varchar('discord_id', { length: 20 }).notNull().unique(),\n  username: varchar('username', { length: 100 }).notNull(),\n  discriminator: varchar('discriminator', { length: 4 }),\n  avatar: text('avatar'),\n  isAdmin: boolean('is_admin').default(false),\n  isModerator: boolean('is_moderator').default(false),\n  createdAt: timestamp('created_at').defaultNow(),\n  updatedAt: timestamp('updated_at').defaultNow()\n});\n\n// Anonymous messages table\nexport const anonymousMessages = pgTable('anonymous_messages', {\n  id: serial('id').primaryKey(),\n  messageId: varchar('message_id', { length: 20 }).notNull().unique(),\n  channelId: varchar('channel_id', { length: 20 }).notNull(),\n  guildId: varchar('guild_id', { length: 20 }).notNull(),\n  authorId: varchar('author_id', { length: 20 }).notNull(),\n  content: text('content').notNull(),\n  userId: text('user_id').notNull(), // Generated anonymous user ID\n  createdAt: timestamp('created_at').defaultNow()\n});\n\n// Security logs table\nexport const securityLogs = pgTable('security_logs', {\n  id: serial('id').primaryKey(),\n  userId: varchar('user_id', { length: 20 }).notNull(),\n  username: varchar('username', { length: 100 }).notNull(),\n  action: varchar('action', { length: 50 }).notNull(),\n  threat: varchar('threat', { length: 100 }),\n  content: text('content'),\n  ipAddress: varchar('ip_address', { length: 45 }),\n  createdAt: timestamp('created_at').defaultNow()\n});\n\n// Polls table\nexport const polls = pgTable('polls', {\n  id: serial('id').primaryKey(),\n  pollId: varchar('poll_id', { length: 50 }).notNull().unique(),\n  messageId: varchar('message_id', { length: 20 }).notNull(),\n  channelId: varchar('channel_id', { length: 20 }).notNull(),\n  guildId: varchar('guild_id', { length: 20 }).notNull(),\n  createdBy: varchar('created_by', { length: 20 }).notNull(),\n  question: text('question').notNull(),\n  options: text('options').notNull(), // JSON string\n  votes: text('votes').notNull(), // JSON string\n  isActive: boolean('is_active').default(true),\n  createdAt: timestamp('created_at').defaultNow(),\n  closedAt: timestamp('closed_at')\n});\n\n// Poll votes table\nexport const pollVotes = pgTable('poll_votes', {\n  id: serial('id').primaryKey(),\n  pollId: varchar('poll_id', { length: 50 }).notNull(),\n  userId: varchar('user_id', { length: 20 }).notNull(),\n  optionIndex: integer('option_index').notNull(),\n  createdAt: timestamp('created_at').defaultNow()\n});\n\n// Rate limiting table\nexport const rateLimits = pgTable('rate_limits', {\n  id: serial('id').primaryKey(),\n  userId: varchar('user_id', { length: 20 }).notNull().unique(),\n  messageCount: integer('message_count').default(0),\n  lastReset: timestamp('last_reset').defaultNow(),\n  isBlocked: boolean('is_blocked').default(false),\n  blockedUntil: timestamp('blocked_until'),\n  createdAt: timestamp('created_at').defaultNow(),\n  updatedAt: timestamp('updated_at').defaultNow()\n});\n\n// Applications table\nexport const applications = pgTable('applications', {\n  id: serial('id').primaryKey(),\n  applicationId: varchar('application_id', { length: 50 }).notNull().unique(),\n  userId: varchar('user_id', { length: 20 }).notNull(),\n  username: varchar('username', { length: 100 }).notNull(),\n  type: varchar('type', { length: 50 }).notNull(), // 'membership', 'staff', etc.\n  content: text('content').notNull(),\n  status: varchar('status', { length: 20 }).default('pending'), // 'pending', 'approved', 'rejected'\n  reviewedBy: varchar('reviewed_by', { length: 20 }),\n  reviewedAt: timestamp('reviewed_at'),\n  reviewNotes: text('review_notes'),\n  createdAt: timestamp('created_at').defaultNow()\n});\n\n// Auctions table\nexport const auctions = pgTable('auctions', {\n  id: serial('id').primaryKey(),\n  auctionId: varchar('auction_id', { length: 50 }).notNull().unique(),\n  messageId: varchar('message_id', { length: 20 }).notNull(),\n  channelId: varchar('channel_id', { length: 20 }).notNull(),\n  sellerId: varchar('seller_id', { length: 20 }).notNull(),\n  title: varchar('title', { length: 200 }).notNull(),\n  description: text('description').notNull(),\n  startingPrice: integer('starting_price').notNull(),\n  currentPrice: integer('current_price').notNull(),\n  buyoutPrice: integer('buyout_price'),\n  highestBidderId: varchar('highest_bidder_id', { length: 20 }),\n  endTime: timestamp('end_time').notNull(),\n  isActive: boolean('is_active').default(true),\n  createdAt: timestamp('created_at').defaultNow()\n});\n\n// Define relations\nexport const usersRelations = relations(users, ({ many }) => ({\n  anonymousMessages: many(anonymousMessages),\n  securityLogs: many(securityLogs),\n  polls: many(polls),\n  pollVotes: many(pollVotes),\n  applications: many(applications),\n  auctions: many(auctions)\n}));\n\nexport const anonymousMessagesRelations = relations(anonymousMessages, ({ one }) => ({\n  author: one(users, {\n    fields: [anonymousMessages.authorId],\n    references: [users.discordId]\n  })\n}));\n\nexport const pollsRelations = relations(polls, ({ one, many }) => ({\n  creator: one(users, {\n    fields: [polls.createdBy],\n    references: [users.discordId]\n  }),\n  votes: many(pollVotes)\n}));\n\nexport const pollVotesRelations = relations(pollVotes, ({ one }) => ({\n  poll: one(polls, {\n    fields: [pollVotes.pollId],\n    references: [polls.pollId]\n  }),\n  user: one(users, {\n    fields: [pollVotes.userId],\n    references: [users.discordId]\n  })\n}));\n\nexport const applicationsRelations = relations(applications, ({ one }) => ({\n  applicant: one(users, {\n    fields: [applications.userId],\n    references: [users.discordId]\n  }),\n  reviewer: one(users, {\n    fields: [applications.reviewedBy],\n    references: [users.discordId]\n  })\n}));\n\nexport const auctionsRelations = relations(auctions, ({ one }) => ({\n  seller: one(users, {\n    fields: [auctions.sellerId],\n    references: [users.discordId]\n  }),\n  highestBidder: one(users, {\n    fields: [auctions.highestBidderId],\n    references: [users.discordId]\n  })\n}));\n\n// Export types\nexport type User = typeof users.$inferSelect;\nexport type InsertUser = typeof users.$inferInsert;\nexport type AnonymousMessage = typeof anonymousMessages.$inferSelect;\nexport type InsertAnonymousMessage = typeof anonymousMessages.$inferInsert;\nexport type SecurityLog = typeof securityLogs.$inferSelect;\nexport type InsertSecurityLog = typeof securityLogs.$inferInsert;\nexport type Poll = typeof polls.$inferSelect;\nexport type InsertPoll = typeof polls.$inferInsert;\nexport type PollVote = typeof pollVotes.$inferSelect;\nexport type InsertPollVote = typeof pollVotes.$inferInsert;\nexport type RateLimit = typeof rateLimits.$inferSelect;\nexport type InsertRateLimit = typeof rateLimits.$inferInsert;\nexport type Application = typeof applications.$inferSelect;\nexport type InsertApplication = typeof applications.$inferInsert;\nexport type Auction = typeof auctions.$inferSelect;\nexport type InsertAuction = typeof auctions.$inferInsert;\n","size_bytes":7127}}}